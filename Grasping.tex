\section{Grasping \& Manipulation System}
\label{sec:manip}
%
\hl{Introduce LBR iiwa + Velvet Fingers 2 Gripper setup}
%
\subsection{Related Work}
\label{subsec:Grasping_related_work}
%
 Current autonomous grasping systems~\cite{Bere07, Srin10, Krug14a}
commonly employ sampling based planners~\cite{LaVa06} to generate online reach-to-grasp motion plans
for offline planned grasps which are stored in a database. During the execution phase, such
approaches necessitate many futile motion planning attempts which often incurs significant time
delays mainly due to the frequent colli- sion checks which are necessary to avoid the robot coming
in contact with itself or the environment.  For APPLE, we adopted a real-time reactive control
approach for manipulator mo- tion generation which allows to exploit redundancy, opposed to the
commonly used sense-plan-act architectures which constrain all manipulator DoF. The main idea is to
formulate a hierarchical set of tasks~\cite{Sams91} such as “move end-effector on this plane” or
“avoid joint limits” and to compute controls such that tasks of lower priorities are exe- cuted in
the null-space of higher ranked tasks~\cite{Sici91, Sent10}.

The aim is to reduce the dependence on classical, sampling based motion planning and to move towards
reactive feedback control to generate and execute complex motion behaviors of a robot.  Here, only
high-level behavioral goals (e. g., “go to this region” or “stay above obstacle plane”) are
specified in form of task functions~\cite{Sams91}. An intelligent control algorithm, which is based
on embedded optimization of these task functions, then handles the details and synthesizes
appropriate motions automatically in an online fashion. Opposed to classical sense-plan-act
architectures, in this paradigm only task-relevant Degrees of Freedom (DoF) need to be constrained,
which allows to exploit kinematic redundancies, e. g., for a manipulator to avoid unexpected
obstacles. Regarding grasp planning, we follow the general tenet and will extract redundant
representations in form of constrained pose intervals instead of discrete poses
%
\subsection{Object Detection}
Typical commissioning scenarios in a warehouse environment would generally involve as a first step the identification and localization of an object targeted for picking.
There are however many application scenario specific factors to consider when designing an object detection system for this task. 
For example: a single pallet may hold a homogeneous or a heterogeneous set of objects; objects may be stored in boxes and equipped with barcodes; objects may be stored on shelves, pallets, or simply piled up.
For the APPLE project we assumed a simple scenario where objects of the same type are stored on a single pallet.
We have equipped the Velvet Fingers 2 gripper with a structured light depth sensor: the Structure IO\footnote{\url{http://structure.io/}} device. 
We use the 3D point clouds generated by the sensor as an input for a simple object detection module which identifies clusters of points matching our expected object models.
The object detection module was implemented using the point cloud library (PCL)\footnote{\url{http://pointclouds.org/}} following the simple algorithm described in Alg.~\ref{alg:obj}.
%
\begin{algorithm}[tbh]
%\DontPrintSemicolon
\SetKwInOut{Input}{input}
\SetKwInOut{Output}{output}
\Input{Pointcloud $P$, kinematic model $K$, joint positions $\mbm{j}$}
\Output{Target cluster $T$}
Transform $P$ into world coordinates using $K,\mbm{j}$\;
\While {target plane not found} {
    Extract plane $\mbm{n},d$ from $P$ using RANSAC\;
    \If{$\mbm{n}\mbm{z} < \cos{\alpha}, abs(d-h_{pallet}) < e_{pallet}$}{target plane found\;}
    \Else{ Remove inliers and iterate. If points in $P$ less than $20\%$ of original points, report failure\;}
}
Extract oriented bounding box (OBB) of plane inliers\;
Extract points inside OBB and height in $(d,d+d_{eps})$\;
Euclidean cluster points in $P_n$\;
\For{each cluster $E_i$} {
    Fit a ML Gaussian to $E_i$ as $\mu_i,\Sigma_i$\;
    Eigen decomposition $\Sigma_i=Q\Lambda Q^{-1}$\;
    Let $\mbm{q}_1$ be the eigenvector associated to the largest eigenvalue $\lambda_1$\;
    \If{$\mbm{q}_1\mbm{z} < \cos{\alpha}$ and $\lambda_2 < r_{max}$} {report target cluster at $\mu_i,\Sigma_i$\;}
}
\caption{Object detection algorithm}\label{alg:obj}
\end{algorithm}
%
\par
The basic idea of Alg.~\ref{alg:obj} is to first detect the location of the pallet plane, then to extract the points belonging to objects on the pallet, cluster them and then analyze the obtained clusters. The parameters in this algorithm are: $h_{pallet}$ --- the expected height of the pallet above floor level; $e_{pallet}$ --- a tolerance of the pallet height; $\alpha$ --- a tolerance on the angle that the pallet plane normal makes with the vertical axis $\mbm{z}$; $r_{max}$ --- the maximum radius of a graspable cylinder. Each of the detected clusters is analyzed using PCA, checking that the dominant point distribution is along the $\mbm{z}$ axis and that the $x-y$ point spread is within the graspable objects limit. Identified target clusters are then passed on to the grasp planning module.
\subsection{Grasp Planning}
\begin{figure*}[t!] 
   \centering
    %\def\svgwidth{200pt} 
    \input{figs/grasp_interval.pdf_tex} 
   \caption{\textit{Grasp interval:} (Left) todo ... (Right) truncated grasp interval ...} 
   \label{fig:grasp_interval}
\end{figure*}
%\FloatBarrier
%

\cite{Bohg14}(data driven grasping) (SotA autonomous grasping systems) \cite{Pas13} cylinder shell
fitting

The key challenge for many applications of robotic mobile manipulation is autonomous grasping in
uncertain real-world environments. Finding collision-free trajec- tories leading the gripper-arm
chain from a given initial to a reachable final state (grasp planning together with vehicle and
manipulator motion planning) constitutes the fundament for any robot manipulation system. Currently,
despite of a large research effort, no commercially viable solution is available for this
problem. In today’s state-of-the-art autonomous grasping systems~\cite{Bere07, Srin10, Krug14a},
grasp planning and motion planning are usually seen as independent sub-problems~\cite{Dian10}. A
database storing object models together with pre-computed grasps is used to relax the need to find
suitable gripper poses/configurations~\cite{Mill04, Gold11, Krug14a}. In the online stage, sampling
based planners~\cite{LaVa06} attempt to generate valid trajectories for the pre-planned grasps,
which are executed in a feasible-first manner~\cite{Bere07}. During the execution phase, such
approaches necessitate many futile motion planning attempts, which often incurs significant time
delays since sampling based planners suffer from the curse of dimensionality. Also, while being able
to solve complicated planning problems if given enough time, these planners don’t scale well to
geometrically simple scenarios~\cite{Ratl09} and they are ill suited to incorporate contact events
with the environment.

 Instead of representing grasps as discrete gripper wrist poses and joint
configurations, we use grasp interval regions as depicted in Fig.~\ref{fig:grasp_interval}. These
grasp intervals can easily be transcribed as target tasks for the manipulator motion control and
allow for redundancy in the manipulator wrist positioning which eases reach-to-grasp
acquisition. Grasp interval formulation depends on the specific target object and has to be verified
experimentally. For now, we constrain ourselves to cylindrical objects as shown in
Fig.~\ref{fig:grasp_interval}. We then rely on the inherent capabilities of the grasping device and
the compliance of the system for successful grasp execution as stated below.


\cite{Bala12}(Identifying grasp principles from humans) \cite{Gien08a, Gien08b, Vahr10}(Task maps with RRT)
%
\subsection{Manipulator Motion Generation}
\label{subsec:manip_motion}
%
 \cite{Sams91}(task functions)
~\cite{Sici91, Sent10}(Redundant motion generation)

We lean on the notation in~\cite{Esca14} and define the manipulator joint configuration by the
vector $\mbm{q}$ and the control inputs as corresponding joint velocities $\dot{\mbm{q}}$. A task
function is any derivable function of $\mbm{e}$. To give an example, a task with the purpose of
bringing an end-effector point $\mbm{p}(\mbm{q})$ onto a plane described by unit normal $\mbm{n}$
and offset $b$ can be transcribed by the task function $\mbm{e}=\mbm{n}^T\mbm{p}(\mbm{q})-d$, which
formulates the projection residual between the plane and $\mbm{p}(\mbm{q})$ \hl{connect example to
  the previously described grasp interval}. The task evolution is given by
$\mbm{J}\dot{\mbm{q}}=\dot{\mbm{e}}$ with task jacobian
$\mbm{J}=\frac{\partial\mbm{e}}{\partial\mbm{q}}$.

Goal is to compute joint velocities such that the task evolution follows a desired reference profile
$\dot{\mbm{e}}^*$ (often chosen as exponential decay $\mbm{e}^*= -\lambda \mbm{e}$, with $\lambda
\in \mathbb{R}_+$). For a single equality task, this necessitates to solve the following least
squares Quadratic Program (QP)
%
\begin{align}\label{eq:QP}
  \dot{q}^* &\in \mbox{arg} \; \underset{\footnotesize\dot{\mbm{q}}\normalsize}{\mbox{min}}||\mbm{J}\dot{\mbm{q}}-\dot{\mbm{e}}^*||.
\end{align}
%
In order to allow for inequality tasks, we henceforth use a general task formulation with upper
bounds 
\begin{align}\label{eq:task}
 \mbm{J}\dot{\mbm{q}}&\leq \mbm{e}^*
\end{align}
%
as in~\cite{Esca14}. This allows to transcribe lower bounds $\mbm{J}\dot{\mbm{q} \geq \mbm{e}^*}$,
double bounds $\dot{\underline{\mbm{e}}}^* \leq \mbm{J}\dot{\mbm{q} \leq \dot{\bar{\mbm{e}}}^*}$ and
equalities $\mbm{J}\dot{\mbm{q}=\mbm{e}^*}$ by reformulating the task respectively as
$-\mbm{J}\dot{\mbm{q} \leq -\mbm{e}^*}$, $\begin{bmatrix} -\mbm{J} \\
  \mbm{J} \end{bmatrix}\dot{\mbm{q}} \leq \begin{bmatrix} -\dot{\underline{\mbm{e}}}^*
  \\ \dot{\bar{\mbm{e}}}^* \end{bmatrix}$ and $\begin{bmatrix} -\mbm{J} \\
  \mbm{J} \end{bmatrix}\dot{\mbm{q}} \leq \begin{bmatrix} -\dot{\mbm{e}}^* \\
  \dot{\mbm{e}}^* \end{bmatrix}$.

If the constraint $\mbm{J}\dot{\mbm{q} \leq \mbm{e}^*}$ is infeasible, a least squares solution for
$\mbm{q}^*$ as in~\eqref{eq:QP} can be found by introducing the slack variable $\mbm{w}$ in the
decision variables
%
\begin{align}\label{eq:iQP}
  &\underset{\dot{\mbm{q}},\;\mbm{w}}{\mbox{min}}\;\;||\mbm{w}||\\
   \mbox{subject to} \quad &\mbm{J}\dot{\mbm{q}} \geq \mbm{e}^* + \mbm{w}. \nonumber
\end{align}
%
To form a stack of hierarchical tasks with $p=1,\dots,P$ priority levels, we stack all task
jacobians in~\eqref{eq:task} with the same assigned priority in a matrix $\mbm{A}_p$, and all
corresponding reference velocities in a vector $\mbm{b}_p$ to form a constraint of the form
$\mbm{A}_p\dot{\mbm{q}}\leq \mbm{b}_p$ for each hierarchy level. The aim is to sequentially satisfy
a constraint at best in the least square sense while solving for the subsequent constraint of lower
priority in the null-space of the previous constraint, such that the previous solution is left
unchanged. Therefore, the following QP, where the previous slack variable solutions $\mbm{w}_i^*$
are frozen between iterations, needs to be solved for $p=1,\ldots,P$
%
\begin{align}\label{eq:HiQP}
  &\underset{\dot{\mbm{q}},\;\mbm{w}_p}{\mbox{min}}\;\;||\mbm{w}_p||\\
   \mbox{subject to} \quad &\mbm{A}_i\dot{\mbm{q}} \leq \mbm{b}_i + \mbm{w}_i^*, \quad i=1,\dots,p-1 \nonumber \\
                           &\mbm{A}_p\dot{\mbm{q}} \leq \mbm{b}_p + \mbm{w}_p.  \nonumber 
\end{align}
%
The final joint velocity vector $\mbm{q}^*$ is obtain from the $P^{\mbox{th}}$ solution
of~\eqref{eq:HiQP}.

For reactive on-the-fly motion generation we formulate a stack of hierarchical tasks and use the
recently developed method by Kanoun et al.~\cite{Kano11}, which allows to account for inequality
tasks and solves a sequence of convex optimization problems at each time step to obtain
appropriate joint velocity commands (the method also can be used to directly generate torque
commands while accounting for the robot dynamics~\cite{Saab13}).
 
Obstacle avoidance is also achieved on a control-level, by formulating tasks which maintain minimum
distances between simple geometric primitives such as spheres, planes, points and capsules. We argue
that for the considered application strict collision avoidance is neither necessary nor desired,
since picking and manipulation inherently necessitates contact events between the robot and the
environment. Also, in real-world applications where knowledge about the environment is available
only in form of noisy sensor data, it might not be possible to avoid contacting the environment
without being overly conservative. This makes the KUKA LBR iiwa with its compliant low-level control
schemes and contact detection abilities an ideal platform for the tackled purpose and motion
generation scheme. The relatively simple picking task in APPLE provides an ideal testbed in a
real-world scenario.

\cite{Kano09}(Task function descriptions)
%
\subsection{Robust Grasp Execution}
\label{subsec:grasp_execution}
%


\begin{figure}[!t]
 \centering
   \includegraphics[width = 1.0\linewidth]{figs/pull_in}
   \caption{\textit{Pull-in grasping strategy:} Depicted is a sequence of intermediate grasp states
     where the belts of the gripper are used to pull the object towards its palm which results in a
     transition from a fingertip to an enveloping grasp.}
   \vspace{-4mm}
   \label{fig:pull_in}
   \centering
 \end{figure}
%
\begin{figure*}[!t]
 \centering
   \subfigure[]{\includegraphics[width = .32\linewidth]{figs/vcg1}}
   \subfigure[]{\includegraphics[width = .32\linewidth]{figs/vcg2}}
   \subfigure[]{\includegraphics[width = .32\linewidth]{figs/vcg3}}
   \caption{\textit{Grasp Execution Control:} As the open griper closes in on the object (Left), the
     current through the opening motor is monitored. When contact is made (Middle), the actuated
     belts are switched on to pull in the object. The controller then strives to maintain the
     current in between two target thresholds by opening or closing the gripper during in-hand
     manipulation (Right).}
   \label{fig:pull_in_control}
 \centering
\end{figure*}
%
For this component, we leverage the capabilities of the Velvet Gripper, namely underactuation and
conveyor belts on the finger pads in order to achieve robust grasping behavior. Especially in
cluttered scenes, a ``pull-in'' strategy has been shown to be especially effective to achieve stable
grasps while starting from a relatively wide range of initial gripper poses with respect to the
target object~\cite{Krug14a}. Here, the features of the grasping device are exploited to embrace the
object in a firm envelope grasp by simultaneously squeezing it in a compliant fashion while
actuating the belts inwards.

(\hl{the following is copy/pasted from the Gripper control workshop paper})~\cite{Krug14c} Each of
the gripper’s two fingers has a planar manipulator structure with two joints and active surfaces
which are implemented by coupled conveyor belts on the inside of the two phalanges. The mechanical
structure is underactuated and comprises only one actuated Degree of Freedom (DoF) for opening and
closing and two DoF for the belt movements.  If, during grasping, the proximal phalanges are blocked
by an object, the gripper’s distal phalanges continue to “wrap around” and envelope it in a firm
grasp.  The experiments reported in~\cite{Krug14a} showed, that in cluttered scenes fingertip
grasps are more likely to be feasible than robust enveloping grasps, because the latter necessitate
large opening angles resulting in bulky gripper silhouettes for which no collision free approach
trajectories can be found. Therefore, we employ the “pull-in” strategy which is illustrated in
Fig.~\ref{nothereyet}. Here, the underactuated nature and the conveyor belts on the grasping device
are exploited to embrace the object in a firm envelope grasp by simultaneously squeezing it while
actuating the belts inwards. This is achieved by compliant low-level position controllers which
saturate on experimentally evaluated current thresholds. We use a simple grasping routine which is
triggered after an initial fingertip grasp is achieved (see Fig.~\ref{nothereyet}). This routine
consists of issuing commands to fully close the gripper while moving the belts a pre-defined offset
towards the palm. Three thresholds on the current absorption of the opening motor are used: a low
threshold (LT) signifies contact between the gripper and the object and a mid threshold (MT)
indicates a large enough contact force to stop the closing movement.  Finally, an upper threshold
(UT) prevents damage to the grasping device. Once the pull-in sequence is completed, the controllers
maintain the final torques to ensure a stable grasp.

